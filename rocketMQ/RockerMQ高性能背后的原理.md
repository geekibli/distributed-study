# RocketMQ高性能背后的原理



## 1.读队列和写队列

在RocketMQ的管理控制台上创建Topic时，可以看到单独设置读队列和写队列。通常在运行时，都需要设置 **读队列=写队列**

<img src="https://oscimg.oschina.net/oscnet/up-789c3b1576f4d699990773e192b2d7d8813.png" style="zoom:50%;" />



> **写队列**： 回去创建专门的存储文件。对消息进行保存。
>
> **读队列**：主要维护消息的offset。



perm字段表示Topic的权限。有三个可选项。

- 2：禁写禁订阅
- 4：可订阅，不能写
- 6：可写可订阅

这其中，写队列会真实的创建对应的存储文件，负责消息写入。而读队列会记录Consumer的Offset，负责消息读取。这其实是一种`读写分离`的思想。RocketMQ 在对MessageQueuel的路由策略时，就可以通过指向不同的队列来实现读写分离。**在往写队列里写Messagel时，会同步写入到一个对应的读队列中。**

<img src="https://oscimg.oschina.net/oscnet/up-d4f7cb7f9cce325b6bd99047b4d17498a01.png" style="zoom:50%;" />

这时，如果写队列大于读队列，就会有一部分写队列无法写入到读队列中，这一部分的消息就无法被读取，就会造成**消息丢失**。

（消息存入了，但是读不出来。）

而如果反过来，写队列小于读队列，那就有一部分读队列里是没有消息写入的。 如果有一个消费者被分配的是这些没有消息的读队列，那这些消费者就无法消费消息，**造成消费者空转**，极大的浪费性能。

<img src="https://oscimg.oschina.net/oscnet/up-2e92ad6c1ae1eacdc8c15b16095286fb2ae.png" style="zoom:50%;" />



**从这里可以看到，写队列>读队列，会造成消息丢失，写队列<读队列，又会造成 消费者空转。所以，在使用时，都是要求写队列=读队列。**





## 2. 消息持久化



![](https://oscimg.oschina.net/oscnet/up-e2036bd271b3bc98a76f00d20a5dc955b2b.png)



CommitLog文件存储所有消息实体。所有生产者发过来的消息，都会无差别 的依次存储到Commitlog文件当中。这样的好处是可以减少查找目标文件的时间， **让消息以最快的速度落盘**。对比Kafka存文件时，需要寻找消息所属的Partition文件，再完成写入，当Topich比较多时，这样的Partition寻址就会浪费比较多的时间， 所以Kafka不太适合多Topic的场景。而RocketMQ的这种快速落盘的方式在多
Topic场景下，优势就比较明显。



### abord文件的作用？

rocketMq崩溃恢复时判断有无abord文件





## 3. 过期文件删除



消息既然要特久化，就必须有对应的删除机制。RocketMQ内置了一套过期文件 的删除机制。



### 3.1 如何判断过期文件

RocketMQ中，CommitLog文件和ConsumeQueue文件都是以偏移量命名，对于非当前写的文件，如果超过了一定的保留时间，那么这些文件都会被认为是过期文件，随时可以删除。这个保留时间就是在broker.conf中配置的**fileReservedTime**属性。



### 3.2 如何删除文件

RocketMQ内部有一个定时任务，对文件进行扫描，并且触发文件删除的操作。 用户可以指定文件删除操作的执行时间。在broker.conf中deleteWhen属性指定。 默认是凌晨四点。

另外，RocketMQ还会检查服务器的磁盘空间是否足够，如果磁盘空间的使用率达到一定的阈值，也会触发过期文件删除。所以RocketMQ官方就特别建议，

**broker的磁盘空间不要少于4G**。

如果消息长时间堆积，没有消费，删除文件的时候（真实删除），就会发生消息丢失。



## 4. 高效文件写

RocketMQ采用了类似于Kafka的文件存储机制，但是文件存储是一个比较重的 操作，需要有非常多的设计才能保证频繁的文件读写场景下的高性能。

### 4.1 零拷贝技术加速文件读写

零拷贝(zro-copy)是操作系统层面提供的一种加速文件读写的操作机制，非常多的开源软件都在大量使用零拷贝，来提升lO操作的性能。对于Jva应用层，对应着 **mmap**和**sendFilei**两种方式。接下来，咱们深入操作系统来详细理解一下零拷贝。



### 4.2 顺序写加速文件写入磁盘





### 4.3 刷盘机制确保消息不丢失







## 5. 消息主从复制

























